'use strict';

var config = require('hardhat/config');
var ethers = require('ethers');
var EthersAdapter = require('@gnosis.pm/safe-ethers-lib');
var SafeServiceClient = require('@gnosis.pm/safe-service-client');
var Safe = require('@gnosis.pm/safe-core-sdk');
var lzDefinitions = require('@layerzerolabs/lz-definitions');
var fs = require('fs');
var cliUx = require('cli-ux');
var chalk = require('chalk');
var promises = require('fs/promises');
var exponentialBackoff = require('exponential-backoff');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var ethers__namespace = /*#__PURE__*/_interopNamespace(ethers);
var EthersAdapter__default = /*#__PURE__*/_interopDefault(EthersAdapter);
var SafeServiceClient__default = /*#__PURE__*/_interopDefault(SafeServiceClient);
var Safe__default = /*#__PURE__*/_interopDefault(Safe);
var fs__default = /*#__PURE__*/_interopDefault(fs);
var chalk__default = /*#__PURE__*/_interopDefault(chalk);

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/constants/abi.ts
var abi_exports = {};
__export(abi_exports, {
  ENDPOINT_ABI: () => ENDPOINT_ABI,
  LZ_APP_ABI: () => LZ_APP_ABI,
  LZ_APP_TRUSTED_REMOTE_LOOKUP_FUNCTION_FRAGMENT: () => LZ_APP_TRUSTED_REMOTE_LOOKUP_FUNCTION_FRAGMENT,
  MESSAGING_LIBRARY_ABI: () => MESSAGING_LIBRARY_ABI,
  USER_APPLICATION_ABI: () => USER_APPLICATION_ABI
});
var ENDPOINT_ABI, MESSAGING_LIBRARY_ABI, USER_APPLICATION_ABI, LZ_APP_TRUSTED_REMOTE_LOOKUP_FUNCTION_FRAGMENT, LZ_APP_ABI;
var init_abi = __esm({
  "src/constants/abi.ts"() {
    ENDPOINT_ABI = [
      "function defaultSendVersion() view returns (uint16)",
      "function defaultReceiveVersion() view returns (uint16)",
      "function defaultSendLibrary() view returns (address)",
      "function defaultReceiveLibraryAddress() view returns (address)",
      "function uaConfigLookup(address) view returns (tuple(uint16 sendVersion, uint16 receiveVersion, address receiveLibraryAddress, address sendLibrary))"
    ];
    MESSAGING_LIBRARY_ABI = [
      "function appConfig(address, uint16) view returns (tuple(uint16 inboundProofLibraryVersion, uint64 inboundBlockConfirmations, address relayer, uint16 outboundProofType, uint64 outboundBlockConfirmations, address oracle))",
      "function defaultAppConfig(uint16) view returns (tuple(uint16 inboundProofLibraryVersion, uint64 inboundBlockConfirmations, address relayer, uint16 outboundProofType, uint64 outboundBlockConfirmations, address oracle))"
    ];
    USER_APPLICATION_ABI = [
      "function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config)",
      "function setSendVersion(uint16 _version)",
      "function setReceiveVersion(uint16 _version)"
    ];
    LZ_APP_TRUSTED_REMOTE_LOOKUP_FUNCTION_FRAGMENT = "function trustedRemoteLookup(uint16) public view returns (bytes)";
    LZ_APP_ABI = [
      "function setTrustedRemote(uint16 _srcChainId, bytes calldata _path)",
      "function setUseCustomAdapterParams(bool _useCustomAdapterParams)",
      "function setDefaultFeeBp(uint16 _feeBp)",
      "function setFeeBp(uint16 _dstChainId, bool _enabled, uint16 _feeBp)",
      "function setMinDstGas(uint16 _dstChainId, uint16 _packetType, uint _minGas)",
      "function useCustomAdapterParams() public view returns (bool) ",
      LZ_APP_TRUSTED_REMOTE_LOOKUP_FUNCTION_FRAGMENT,
      "function minDstGasLookup(uint16, uint16) public view returns (uint)",
      "function defaultFeeBp() public view returns (uint16)",
      "function chainIdToFeeBps(uint16) public view returns (uint16, bool)"
    ];
  }
});

// src/index.ts
init_abi();

// src/utils/crossChainHelper.ts
init_abi();

// src/constants/endpoints.ts
var LZ_ENDPOINTS = {
  "aavegotchi-testnet": "0xfeBE4c839EFA9f506C092a32fD0BB546B76A1d38",
  "arbitrum-mainnet": "0x3c2269811836af69497E5F486A85D7316753cf62",
  "arbitrum-testnet": "0x6aB5Ae6822647046626e83ee6dB8187151E1d5ab",
  "astar-mainnet": "0xb6319cC6c8c27A8F5dAF0dD3DF91EA35C4720dd7",
  "aurora-mainnet": "0xb6319cC6c8c27A8F5dAF0dD3DF91EA35C4720dd7",
  "aurora-testnet": "0x83c73Da98cf733B03315aFa8758834b36a195b87",
  "avalanche-mainnet": "0x3c2269811836af69497E5F486A85D7316753cf62",
  "avalanche-testnet": "0x93f54D755A063cE7bB9e6Ac47Eccc8e33411d706",
  "base-mainnet": "0xb6319cC6c8c27A8F5dAF0dD3DF91EA35C4720dd7",
  "base-testnet": "0x6aB5Ae6822647046626e83ee6dB8187151E1d5ab",
  "blockgen-testnet": "0x55370E0fBB5f5b8dAeD978BA1c075a499eB107B8",
  "bsc-mainnet": "0x3c2269811836af69497E5F486A85D7316753cf62",
  "bsc-testnet": "0x6Fcb97553D41516Cb228ac03FdC8B9a0a9df04A1",
  "canto-mainnet": "0x9740FF91F1985D8d2B71494aE1A2f723bb3Ed9E4",
  "canto-testnet": "0xae92d5aD7583AD66E49A0c67BAd18F6ba52dDDc1",
  "celo-mainnet": "0x3A73033C0b1407574C76BdBAc67f126f6b4a9AA9",
  "celo-testnet": "0xae92d5aD7583AD66E49A0c67BAd18F6ba52dDDc1",
  "conflux-mainnet": "0xb6319cC6c8c27A8F5dAF0dD3DF91EA35C4720dd7",
  "conflux-testnet": "0x83c73Da98cf733B03315aFa8758834b36a195b87",
  "coredao-mainnet": "0x9740FF91F1985D8d2B71494aE1A2f723bb3Ed9E4",
  "coredao-testnet": "0xae92d5aD7583AD66E49A0c67BAd18F6ba52dDDc1",
  "dexalot-mainnet": "0x9740FF91F1985D8d2B71494aE1A2f723bb3Ed9E4",
  "dexalot-testnet": "0x6C7Ab2202C98C4227C5c46f1417D81144DA716Ff",
  "dfk-mainnet": "0x9740FF91F1985D8d2B71494aE1A2f723bb3Ed9E4",
  "dos-testnet": "0x45841dd1ca50265Da7614fC43A361e526c0e6160",
  "eon-testnet": "0x83c73Da98cf733B03315aFa8758834b36a195b87",
  "ethereum-mainnet": "0x66A71Dcef29A0fFBDBE3c6a460a3B5BC225Cd675",
  "ethereum-testnet": "0xbfD2135BFfbb0B5378b56643c2Df8a87552Bfa23",
  "fantom-mainnet": "0xb6319cC6c8c27A8F5dAF0dD3DF91EA35C4720dd7",
  "fantom-testnet": "0x7dcAD72640F835B0FA36EFD3D6d3ec902C7E5acf",
  "fuse-mainnet": "0x9740FF91F1985D8d2B71494aE1A2f723bb3Ed9E4",
  "gnosis-mainnet": "0x9740FF91F1985D8d2B71494aE1A2f723bb3Ed9E4",
  "gnosis-testnet": "0xae92d5aD7583AD66E49A0c67BAd18F6ba52dDDc1",
  "harmony-mainnet": "0x9740FF91F1985D8d2B71494aE1A2f723bb3Ed9E4",
  "harmony-testnet": "0xae92d5aD7583AD66E49A0c67BAd18F6ba52dDDc1",
  "hubble-testnet": "0x8b14D287B4150Ff22Ac73DF8BE720e933f659abc",
  "idex-testnet": "0x55370E0fBB5f5b8dAeD978BA1c075a499eB107B8",
  "kava-mainnet": "0xb6319cC6c8c27A8F5dAF0dD3DF91EA35C4720dd7",
  "kava-testnet": "0x8b14D287B4150Ff22Ac73DF8BE720e933f659abc",
  "klaytn-mainnet": "0x9740FF91F1985D8d2B71494aE1A2f723bb3Ed9E4",
  "klaytn-testnet": "0x6aB5Ae6822647046626e83ee6dB8187151E1d5ab",
  "lif3-testnet": "0x55370E0fBB5f5b8dAeD978BA1c075a499eB107B8",
  "loot-mainnet": "0xb6319cC6c8c27A8F5dAF0dD3DF91EA35C4720dd7",
  "loot-testnet": "0x83c73Da98cf733B03315aFa8758834b36a195b87",
  "mantle-mainnet": "0xb6319cC6c8c27A8F5dAF0dD3DF91EA35C4720dd7",
  "mantle-testnet": "0x2cA20802fd1Fd9649bA8Aa7E50F0C82b479f35fe",
  "meritcircle-mainnet": "0xb6319cC6c8c27A8F5dAF0dD3DF91EA35C4720dd7",
  "meritcircle-testnet": "0xae92d5aD7583AD66E49A0c67BAd18F6ba52dDDc1",
  "meter-mainnet": "0xa3a8e19253Ab400acDac1cB0eA36B88664D8DedF",
  "meter-testnet": "0x3De2f3D1Ac59F18159ebCB422322Cb209BA96aAD",
  "metis-mainnet": "0x9740FF91F1985D8d2B71494aE1A2f723bb3Ed9E4",
  "metis-testnet": "0xae92d5aD7583AD66E49A0c67BAd18F6ba52dDDc1",
  "moonbeam-mainnet": "0x9740FF91F1985D8d2B71494aE1A2f723bb3Ed9E4",
  "moonbeam-testnet": "0xb23b28012ee92E8dE39DEb57Af31722223034747",
  "moonriver-mainnet": "0x7004396C99D5690da76A7C59057C5f3A53e01704",
  "nova-mainnet": "0x4EE2F9B7cf3A68966c370F3eb2C16613d3235245",
  "okx-mainnet": "0x9740FF91F1985D8d2B71494aE1A2f723bb3Ed9E4",
  "okx-testnet": "0xae92d5aD7583AD66E49A0c67BAd18F6ba52dDDc1",
  "opbnb-mainnet": "0xb6319cC6c8c27A8F5dAF0dD3DF91EA35C4720dd7",
  "opbnb-testnet": "0x83c73Da98cf733B03315aFa8758834b36a195b87",
  "optimism-mainnet": "0x3c2269811836af69497E5F486A85D7316753cf62",
  "optimism-testnet": "0xae92d5aD7583AD66E49A0c67BAd18F6ba52dDDc1",
  "orderly-testnet": "0x83c73Da98cf733B03315aFa8758834b36a195b87",
  "polygon-mainnet": "0x3c2269811836af69497E5F486A85D7316753cf62",
  "polygon-testnet": "0xf69186dfBa60DdB133E91E9A4B5673624293d8F8",
  "portal-testnet": "0xd682ECF100f6F4284138AA925348633B0611Ae21",
  "scroll-mainnet": "0xb6319cC6c8c27A8F5dAF0dD3DF91EA35C4720dd7",
  "scroll-testnet": "0x6098e96a28E02f27B1e6BD381f870F1C8Bd169d3",
  "sepolia-mainnet": "0x7cacBe439EaD55fa1c22790330b12835c6884a91",
  "sepolia-testnet": "0xae92d5aD7583AD66E49A0c67BAd18F6ba52dDDc1",
  "shimmer-testnet": "0x83c73Da98cf733B03315aFa8758834b36a195b87",
  "telos-mainnet": "0x66A71Dcef29A0fFBDBE3c6a460a3B5BC225Cd675",
  "telos-testnet": "0x83c73Da98cf733B03315aFa8758834b36a195b87",
  "tenet-mainnet": "0x2D61DCDD36F10b22176E0433B86F74567d529aAa",
  "tenet-testnet": "0x6aB5Ae6822647046626e83ee6dB8187151E1d5ab",
  "tomo-mainnet": "0xb6319cC6c8c27A8F5dAF0dD3DF91EA35C4720dd7",
  "tomo-testnet": "0xae92d5aD7583AD66E49A0c67BAd18F6ba52dDDc1",
  "xpla-testnet": "0x83c73Da98cf733B03315aFa8758834b36a195b87",
  "zkconsensys-mainnet": "0xb6319cC6c8c27A8F5dAF0dD3DF91EA35C4720dd7",
  "zkconsensys-testnet": "0x6aB5Ae6822647046626e83ee6dB8187151E1d5ab",
  "zkpolygon-mainnet": "0x9740FF91F1985D8d2B71494aE1A2f723bb3Ed9E4",
  "zkpolygon-testnet": "0x6aB5Ae6822647046626e83ee6dB8187151E1d5ab",
  "zksync-mainnet": "0x9b896c0e23220469C7AE69cb4BbAE391eAa4C8da",
  "zksync-testnet": "0x093D2CF57f764f09C3c2Ac58a42A2601B8C79281",
  "zora-mainnet": "0xb6319cC6c8c27A8F5dAF0dD3DF91EA35C4720dd7",
  "zora-testnet": "0x83c73Da98cf733B03315aFa8758834b36a195b87"
};
var GNOSIS_SAFE_FILE_ENCODING = "utf-8";
var toContractNetworksString = (contractNetworks) => {
  if (contractNetworks === void 0) {
    return "";
  }
  return Object.entries(contractNetworks).reduce((accumulator, [chainListId, config]) => {
    return accumulator + `contractNetworks[chainListId=${chainListId}, multiSendAddress=${config.multiSendAddress}, safeMasterCopyAddress=${config.safeMasterCopyAddress}, safeProxyFactoryAddress=${config.safeProxyFactoryAddress}]`;
  }, "");
};
var getSafeConfigs = (fileName) => {
  return JSON.parse(fs.readFileSync(fileName, GNOSIS_SAFE_FILE_ENCODING));
};
var promptToProceed = async (msg, noPrompt = false) => {
  if (!noPrompt) {
    const proceed = await cliUx.cli.prompt(`${msg} Y/N`);
    if (!["y", "yes"].includes(proceed.toLowerCase())) {
      process.exit(0);
    }
  }
};
var arrayToCsv = (columns, data) => columns.join(",").concat("\n").concat(
  data.map(
    (row) => row.map(String).map((v) => v === "undefined" ? "" : v).map((v) => v.replace(/"/g, '""')).map((v) => `"${v}"`).join(",")
    // comma-separated
  ).join("\r\n")
  // rows starting on new lines
);
var writeToCsv = async (fileName, columns, transactionByNetwork) => {
  const data = transactionByNetwork.reduce((acc, { network, transactions }) => {
    transactions.forEach((tx) => {
      acc.push([
        network,
        ...columns.map((key) => {
          const keys = key.split("/");
          for (const field in tx) {
            if (keys.includes(field)) {
              if (typeof tx[field] === "object") {
                return JSON.stringify(tx[field]);
              } else {
                return tx[field];
              }
            }
          }
        })
      ]);
    });
    return acc;
  }, []);
  fs__default.default.writeFileSync(fileName, arrayToCsv(["network"].concat(columns), data));
  console.log(`Transactions are written to: ${chalk__default.default.green(fileName)}`);
};
var printTransactions = (columns, transactionByNetwork) => {
  let totalTransactionsNeedingChange = 0;
  transactionByNetwork.forEach(({ network, transactions }) => {
    console.log(`
================================================`);
    console.log(chalk__default.default.green(`${network.toUpperCase()} transactions`));
    console.log(`================================================`);
    const transactionsNeedingChange = transactions.filter((tx) => tx.needChange);
    totalTransactionsNeedingChange += transactionsNeedingChange.length;
    if (!transactionsNeedingChange.length) {
      console.log("No changes needed\n");
    } else {
      console.table(transactionsNeedingChange, columns);
    }
  });
};
var logError = (message, includeErrorText = true) => console.log(chalk__default.default.red(includeErrorText ? `ERROR: ${message}` : message));
var logWarning = (message) => console.log(chalk__default.default.yellow(`WARNING: ${message}`));
var logSuccess = (message) => console.log(chalk__default.default.green(`${message}`));
var configExist = (fileName) => fs__default.default.existsSync(fileName);
var getConfig = (fileName) => JSON.parse(fs__default.default.readFileSync(fileName, "utf-8"));
var path = __require("path");
var fs2 = __require("fs");
var providerByNetwork = {};
var getProvider = (hre, network) => {
  if (!providerByNetwork[network]) {
    const networkUrl = hre.config.networks[network].url;
    providerByNetwork[network] = new ethers__namespace.providers.JsonRpcProvider(networkUrl);
  }
  return providerByNetwork[network];
};
var getWallet = (index) => ethers__namespace.Wallet.fromMnemonic(process.env.MNEMONIC || "", `m/44'/60'/0'/0/${index}`);
var connectedWallets = {};
var getConnectedWallet = (hre, network, walletIndex) => {
  const key = `${network}-${walletIndex}`;
  if (!connectedWallets[key]) {
    const provider = getProvider(hre, network);
    const wallet = getWallet(walletIndex);
    connectedWallets[key] = wallet.connect(provider);
  }
  return connectedWallets[key];
};
var deploymentAddresses = {};
var getDeploymentAddress = (network, contractName) => {
  const key = `${network}-${contractName}`;
  if (!deploymentAddresses[key]) {
    deploymentAddresses[key] = getDeploymentAddresses(network)[contractName];
  }
  if (!deploymentAddresses[key]) {
    throw Error(`contract ${key} not found for network: ${network}`);
  }
  return deploymentAddresses[key];
};
var contracts = {};
var getContract = async (hre, network, contractName) => {
  if (network == "hardhat") {
    return await hre.ethers.getContract(contractName);
  }
  const key = `${network}-${contractName}`;
  if (!contracts[key]) {
    const contractAddress = getDeploymentAddress(network, contractName);
    const provider = getProvider(hre, network);
    const contractFactory = await getContractFactory(hre, contractName);
    const contract = contractFactory.attach(contractAddress);
    contracts[key] = contract.connect(provider);
  }
  return contracts[key];
};
var getContractAt = async (hre, network, abi, contractAddress) => {
  const key = `${network}-${contractAddress}`;
  if (!contracts[key]) {
    const provider = getProvider(hre, network);
    const contract = new ethers.Contract(contractAddress, abi, provider);
    contracts[key] = contract.connect(provider);
  }
  return contracts[key];
};
var getWalletContract = async (hre, network, contractName, walletIndex = 0) => {
  const contract = await getContract(hre, network, contractName);
  const wallet = getConnectedWallet(hre, network, walletIndex);
  return contract.connect(wallet);
};
var getWalletContractAt = async (hre, network, abi, contractAddress, walletIndex = 0) => {
  const contract = await getContractAt(hre, network, abi, contractAddress);
  const wallet = getConnectedWallet(hre, network, walletIndex);
  return contract.connect(wallet);
};
var contractFactories = {};
var getContractFactory = async (hre, contractName) => {
  if (!contractFactories[contractName]) {
    contractFactories[contractName] = await hre.ethers.getContractFactory(contractName);
  }
  return contractFactories[contractName];
};
var executeTransaction = async (hre, network, transaction, gasLimit, contract, abi) => {
  let walletContract;
  if (contract) {
    walletContract = contract;
  } else if (hre.ethers.utils.isAddress(transaction.contractName)) {
    walletContract = await getWalletContractAt(hre, network, abi, transaction.contractName, 0);
  } else {
    walletContract = await getWalletContract(hre, network, transaction.contractName, 0);
  }
  const gasPrice = await getProvider(hre, network).getGasPrice();
  const finalGasPrice = gasPrice.mul(10).div(8);
  return await (await walletContract[transaction.functionName](...transaction.args, {
    gasPrice: finalGasPrice,
    gasLimit: gasLimit !== void 0 ? gasLimit : 2e5,
    ...transaction.txArgs
  })).wait();
};
async function executeTransactions(hre, taskArgs, transactionBynetwork) {
  const columns = ["needChange", "chainId", "remoteChainId", "contractName", "functionName", "args", "diff", "calldata"];
  const data = transactionBynetwork.reduce((acc, { network, transactions }) => {
    transactions.forEach((transaction) => {
      acc.push([
        network,
        ...columns.map((key) => {
          if (typeof transaction[key] === "object") {
            return JSON.stringify(transaction[key]);
          } else {
            return transaction[key];
          }
        })
      ]);
    });
    return acc;
  }, []);
  await promises.writeFile("./transactions.csv", arrayToCsv(["network"].concat(columns), data));
  console.log("Full configuration is written at:");
  console.log(`file:/${process.cwd()}/transactions.csv`);
  const errs = [];
  const print = {};
  let previousPrintLine = 0;
  const printResult = () => {
    if (previousPrintLine) {
      process.stdout.moveCursor(0, -previousPrintLine);
    }
    if (Object.keys(print)) {
      previousPrintLine = Object.keys(print).length + 4;
      console.table(Object.keys(print).map((network) => ({ network, ...print[network] })));
    }
  };
  if (taskArgs.n) {
    await promptToProceed("Would you like to Submit to gnosis?", taskArgs.noPrompt);
    const gnosisConfig = getSafeConfigs(taskArgs.gnosisConfigPath);
    await Promise.all(
      transactionBynetwork.map(async ({ network, transactions }) => {
        const transactionToCommit = transactions.filter((transaction) => transaction.needChange);
        print[network] = print[network] || { requests: `1/1` };
        print[network].current = `executeGnosisTransactions: ${transactionToCommit}`;
        try {
          await executeGnosisTransactions(hre, network, gnosisConfig, transactionToCommit);
          print[network].requests = `1/1`;
          printResult();
        } catch (err) {
          console.log(`Failing calling executeGnosisTransactions for network ${network} with err ${err}`);
          errs.push({
            network,
            err
          });
          print[network].current = err.message;
          print[network].err = true;
          printResult();
        }
      })
    );
  } else {
    await promptToProceed("Would you like to run these transactions?", taskArgs.noPrompt);
    await Promise.all(
      transactionBynetwork.map(async ({ network, transactions }) => {
        const transactionToCommit = transactions.filter((transaction) => transaction.needChange);
        let successTx = 0;
        print[network] = print[network] || { requests: `${successTx}/${transactionToCommit.length}` };
        for (let transaction of transactionToCommit) {
          print[network].current = `${transaction.contractName}.${transaction.functionName}`;
          printResult();
          try {
            const gasLimit = taskArgs.gasLimit;
            const tx = await executeTransaction(hre, network, transaction, gasLimit);
            print[network].past = `${transaction.contractName}.${transaction.functionName} (${tx.transactionHash})`;
            successTx++;
            print[network].requests = `${successTx}/${transactionToCommit.length}`;
            printResult();
          } catch (err) {
            console.log(`Failing calling ${transaction.contractName}.${transaction.functionName} for network ${network} with err ${err}`);
            console.log(err);
            errs.push({
              network,
              err
            });
            print[network].current = err;
            print[network].err = true;
            printResult();
            break;
          }
        }
      })
    );
  }
  if (!errs.length) {
    console.log("Wired all networks successfully");
  } else {
    console.log(errs);
  }
}
var executeGnosisTransactions = async (hre, network, gnosisConfig, transactions) => {
  const signer = await getConnectedWallet(hre, network, 0);
  if (!gnosisConfig[network]) {
    throw Error(`Gnosis for ${network} not found or not supported`);
  }
  const { safeAddress, url, contractNetworks } = gnosisConfig[network];
  console.log(`safeAddress[${safeAddress}] url[${url}] ${toContractNetworksString(contractNetworks)}`);
  const safeService = new SafeServiceClient__default.default(url);
  const ethAdapter = new EthersAdapter__default.default({
    ethers: hre.ethers,
    signerOrProvider: signer
  });
  const safeSdk = await Safe__default.default.create({ ethAdapter, safeAddress, ...!!contractNetworks && { contractNetworks } });
  const gnosisTransactions = transactions.map((tx) => ({ to: tx.contractAddress, data: tx.calldata, value: "0" }));
  if (gnosisTransactions.length > 0) {
    const nonce = await safeService.getNextNonce(safeAddress);
    const safeTransaction = await safeSdk.createTransaction(gnosisTransactions, { nonce });
    await safeSdk.signTransaction(safeTransaction);
    const safeTxHash = await safeSdk.getTransactionHash(safeTransaction);
    await safeService.proposeTransaction({
      safeAddress,
      safeTransaction,
      safeTxHash,
      senderAddress: signer.address
    });
  } else {
    console.log(`No transactions to submit for ${network}`);
  }
};
var getDeploymentAddresses = (network, throwIfMissing = true) => {
  const deploymentAddresses2 = {};
  const DEPLOYMENT_PATH = path.resolve("deployments");
  if (!fs2.existsSync(DEPLOYMENT_PATH)) {
    return deploymentAddresses2;
  }
  let folderName = network;
  if (network === "hardhat") {
    folderName = "localhost";
  }
  const networkFolderName = fs2.readdirSync(DEPLOYMENT_PATH).filter((f) => f === folderName)[0];
  if (networkFolderName === void 0) {
    if (throwIfMissing) {
      throw new Error("missing deployment files for endpoint " + folderName);
    }
    return deploymentAddresses2;
  }
  const networkFolderPath = path.resolve(DEPLOYMENT_PATH, folderName);
  const files = fs2.readdirSync(networkFolderPath).filter((f) => f.includes(".json"));
  files.forEach((file) => {
    const filepath = path.resolve(networkFolderPath, file);
    const data = JSON.parse(fs2.readFileSync(filepath));
    const contractName = file.split(".")[0];
    deploymentAddresses2[contractName] = data.address;
  });
  return deploymentAddresses2;
};
var getApplicationConfig = async (remoteNetwork, sendLibrary, receiveLibrary, applicationAddress) => {
  const remoteChainId = getLayerZeroChainId(remoteNetwork);
  const sendConfig = await sendLibrary.appConfig(applicationAddress, remoteChainId);
  let inboundProofLibraryVersion = sendConfig.inboundProofLibraryVersion;
  let inboundBlockConfirmations = sendConfig.inboundBlockConfirmations.toNumber();
  if (receiveLibrary) {
    const receiveConfig = await receiveLibrary.appConfig(applicationAddress, remoteChainId);
    inboundProofLibraryVersion = receiveConfig.inboundProofLibraryVersion;
    inboundBlockConfirmations = receiveConfig.inboundBlockConfirmations.toNumber();
  }
  return {
    remoteNetwork,
    inboundProofLibraryVersion,
    inboundBlockConfirmations,
    relayer: sendConfig.relayer,
    outboundProofType: sendConfig.outboundProofType,
    outboundBlockConfirmations: sendConfig.outboundBlockConfirmations.toNumber(),
    oracle: sendConfig.oracle
  };
};
var getEndpointAddress = (network) => {
  return LZ_ENDPOINTS[network];
};
var getLayerZeroChainId = (network) => {
  const [chainName, environment] = network.split("-");
  const chainIdEnum = getChainIdEnum(chainName, environment);
  if (environment == "mainnet") {
    return lzDefinitions.MainnetEndpointId[chainIdEnum];
  } else if (environment == "testnet") {
    return lzDefinitions.TestnetEndpointId[chainIdEnum];
  } else if (environment == "sandbox") {
    return lzDefinitions.SandboxEndpointId[chainIdEnum];
  } else {
    throw new Error("cannot find chainId");
  }
};
var getChainIdEnum = (chainName, environment) => {
  return `${chainName.split("-")[0].toUpperCase()}_${environment.toUpperCase()}`;
};
var getContractInstance = async (hre, network, contractNameOrAddress) => {
  let contract;
  if (hre.ethers.utils.isAddress(contractNameOrAddress)) {
    contract = await getContractAt(hre, network, LZ_APP_ABI, contractNameOrAddress);
  } else {
    contract = await getContract(hre, network, contractNameOrAddress);
  }
  return contract;
};

// src/utils/wireAllHelpers.ts
async function setUseCustomAdapterParams(hre, localNetwork, localContractNameOrAddress, useCustom) {
  const localContract = await getContractInstance(hre, localNetwork, localContractNameOrAddress);
  const cur = await localContract.useCustomAdapterParams();
  const needChange = cur !== useCustom;
  const functionName = "setUseCustomAdapterParams";
  let args = [useCustom];
  const tx = {
    needChange,
    chainId: getLayerZeroChainId(localNetwork),
    contractName: localContractNameOrAddress,
    functionName,
    args,
    calldata: localContract.interface.encodeFunctionData(functionName, args)
  };
  if (tx.needChange) {
    tx.diff = JSON.stringify({ useCustomAdapterParams: { oldValue: cur, newValue: useCustom } });
  }
  return [tx];
}
async function setMinDstGas(hre, localNetwork, localContractNameOrAddress, minDstGasConfig, remoteChainId) {
  const txns = [];
  const localContract = await getContractInstance(hre, localNetwork, localContractNameOrAddress);
  const packetTypes = Object.keys(minDstGasConfig);
  for (const packet of packetTypes) {
    let packetType = parseInt(packet.at(-1));
    const minGas = minDstGasConfig[packet];
    const cur = (await localContract.minDstGasLookup(remoteChainId, packetType)).toNumber();
    const needChange = cur !== minGas;
    const functionName = "setMinDstGas";
    let args = [remoteChainId, packetType, minGas];
    const tx = {
      needChange,
      chainId: getLayerZeroChainId(localNetwork),
      contractName: localContractNameOrAddress,
      functionName,
      args,
      calldata: localContract.interface.encodeFunctionData(functionName, args)
    };
    if (tx.needChange) {
      tx.diff = JSON.stringify({ oldValue: cur, newValue: minGas });
    }
    txns.push(tx);
  }
  return txns;
}
async function setTrustedRemote(hre, localNetwork, localContractNameOrAddress, remoteNetwork, remoteContractNameOrAddress) {
  const localContract = await getContractInstance(hre, localNetwork, localContractNameOrAddress);
  const remoteContract = await getContractInstance(hre, remoteNetwork, remoteContractNameOrAddress);
  const remoteContractAddress = await remoteContract.address;
  const desiredTrustedRemote = hre.ethers.utils.solidityPack(["bytes"], [remoteContractAddress + localContract.address.substring(2)]);
  const remoteChainId = getLayerZeroChainId(remoteNetwork);
  const cur = await localContract.trustedRemoteLookup(remoteChainId);
  const needChange = cur != desiredTrustedRemote;
  const functionName = "setTrustedRemote";
  let args = [remoteChainId, desiredTrustedRemote];
  const tx = {
    needChange,
    chainId: getLayerZeroChainId(localNetwork),
    contractName: localContractNameOrAddress,
    functionName,
    args,
    calldata: localContract.interface.encodeFunctionData(functionName, args)
  };
  if (tx.needChange) {
    tx.diff = JSON.stringify({ trustedRemote: { oldValue: cur, newValue: desiredTrustedRemote } });
  }
  return [tx];
}
function getContractNameOrAddress(chain, WIRE_UP_CONFIG) {
  let contractNameOrAddress;
  const proxyChain = WIRE_UP_CONFIG?.proxyContractConfig?.chain;
  if (proxyChain === chain) {
    if (WIRE_UP_CONFIG?.proxyContractConfig?.name) {
      contractNameOrAddress = WIRE_UP_CONFIG?.proxyContractConfig?.name;
    } else if (WIRE_UP_CONFIG?.proxyContractConfig?.address) {
      contractNameOrAddress = WIRE_UP_CONFIG?.proxyContractConfig?.address;
    }
  } else {
    if (WIRE_UP_CONFIG?.contractConfig?.name) {
      contractNameOrAddress = WIRE_UP_CONFIG?.contractConfig?.name;
    } else if (WIRE_UP_CONFIG?.chainConfig?.[chain]?.name) {
      contractNameOrAddress = WIRE_UP_CONFIG?.chainConfig?.[chain]?.name;
    } else if (WIRE_UP_CONFIG?.chainConfig?.[chain]?.address) {
      contractNameOrAddress = WIRE_UP_CONFIG?.chainConfig?.[chain]?.address;
    }
  }
  return contractNameOrAddress;
}

// src/wireAll.ts
async function wireAll_default(taskArgs, hre) {
  if (!configExist(taskArgs.configPath)) {
    logError(`Wire up config file is not found.`);
    return;
  }
  if (taskArgs.n && !configExist(taskArgs.gnosisConfigPath)) {
    logError(`Gnosis config file not found`);
    return;
  }
  const deployer = (await hre.getNamedAccounts()).deployer;
  console.log(`CURRENT SIGNER: ${deployer}`);
  const WIRE_UP_CONFIG = getConfig(taskArgs.configPath);
  const localNetworks = Object.keys(WIRE_UP_CONFIG?.chainConfig);
  console.log(`************************************************`);
  console.log(`Computing diff`);
  console.log(`************************************************`);
  let transactionByNetwork = await Promise.all(
    localNetworks.map(async (localNetwork) => {
      const transactions = [];
      const remoteNetworks = Object.keys(WIRE_UP_CONFIG?.chainConfig?.[localNetwork]?.remoteNetworkConfig);
      let localContractNameOrAddress = getContractNameOrAddress(localNetwork, WIRE_UP_CONFIG);
      if (localContractNameOrAddress === void 0) {
        logError(`Invalid wire up config for localContractNameOrAddress.`);
        return;
      }
      const useCustomAdapterParams = WIRE_UP_CONFIG?.chainConfig?.[localNetwork]?.useCustomAdapterParams;
      if (useCustomAdapterParams !== void 0) {
        transactions.push(...await setUseCustomAdapterParams(hre, localNetwork, localContractNameOrAddress, useCustomAdapterParams));
      }
      const defaultFeeBp = WIRE_UP_CONFIG?.chainConfig?.[localNetwork]?.defaultFeeBp;
      if (defaultFeeBp !== void 0) {
        transactions.push(...await setDefaultFeeBp(hre, localNetwork, localContractNameOrAddress, defaultFeeBp));
      }
      await Promise.all(
        remoteNetworks.map(async (remoteNetwork) => {
          if (localNetwork === remoteNetwork)
            return;
          WIRE_UP_CONFIG?.proxyContractConfig?.chain;
          let remoteContractNameOrAddress = getContractNameOrAddress(remoteNetwork, WIRE_UP_CONFIG);
          if (remoteContractNameOrAddress === void 0) {
            logError(`Invalid wire up config for remoteContractNameOrAddress.`);
            return;
          }
          transactions.push(...await setTrustedRemote(hre, localNetwork, localContractNameOrAddress, remoteNetwork, remoteContractNameOrAddress));
          if (WIRE_UP_CONFIG?.chainConfig?.[localNetwork]?.remoteNetworkConfig?.[remoteNetwork]?.feeBpConfig !== void 0) {
            transactions.push(...await setFeeBp(hre, localNetwork, localContractNameOrAddress, WIRE_UP_CONFIG?.chainConfig?.[localNetwork]?.remoteNetworkConfig?.[remoteNetwork].feeBpConfig, getLayerZeroChainId(remoteNetwork)));
          }
          if (WIRE_UP_CONFIG?.chainConfig?.[localNetwork]?.remoteNetworkConfig?.[remoteNetwork]?.minDstGasConfig !== void 0) {
            transactions.push(...await setMinDstGas(hre, localNetwork, localContractNameOrAddress, WIRE_UP_CONFIG?.chainConfig?.[localNetwork]?.remoteNetworkConfig?.[remoteNetwork].minDstGasConfig, getLayerZeroChainId(remoteNetwork)));
          }
        })
      );
      return {
        network: localNetwork,
        transactions
      };
    })
  );
  const noChanges = transactionByNetwork.reduce((acc, { transactions }) => {
    acc += transactions.filter((transaction) => transaction.needChange).length;
    return acc;
  }, 0);
  if (noChanges == 0) {
    console.log("No changes needed");
    return;
  }
  const columns = ["needChange", "chainId", "contractName", "functionName", "args", "diff"];
  printTransactions(columns, transactionByNetwork);
  await executeTransactions(hre, taskArgs, transactionByNetwork);
}
async function setDefaultFeeBp(hre, localNetwork, localContractNameOrAddress, defaultFeeBp) {
  const localContract = await getContractInstance(hre, localNetwork, localContractNameOrAddress);
  const cur = await localContract.defaultFeeBp();
  const needChange = cur !== defaultFeeBp;
  const functionName = "setDefaultFeeBp";
  let args = [defaultFeeBp];
  const tx = {
    needChange,
    chainId: getLayerZeroChainId(localNetwork),
    contractName: localContractNameOrAddress,
    functionName,
    args,
    calldata: localContract.interface.encodeFunctionData(functionName, args)
  };
  if (tx.needChange) {
    tx.diff = JSON.stringify({ defaultFeeBp: { oldValue: cur, newValue: defaultFeeBp } });
  }
  return [tx];
}
async function setFeeBp(hre, localNetwork, localContractNameOrAddress, feeBpConfig, remoteChainId) {
  const localContract = await getContractInstance(hre, localNetwork, localContractNameOrAddress);
  const feeConfig = await localContract.chainIdToFeeBps(remoteChainId);
  const curFeeBp = feeConfig[0];
  const curEnabled = feeConfig[1];
  const needChange = curFeeBp !== feeBpConfig.feeBp || curEnabled !== feeBpConfig.enabled;
  const functionName = "setFeeBp";
  const args = [remoteChainId, feeBpConfig.enabled, feeBpConfig.feeBp];
  localContract.interface.encodeFunctionData(functionName, args);
  const tx = {
    needChange,
    chainId: getLayerZeroChainId(localNetwork),
    contractName: localContractNameOrAddress,
    functionName,
    args,
    calldata: localContract.interface.encodeFunctionData(functionName, args)
  };
  if (tx.needChange) {
    tx.diff = JSON.stringify({ feeBp: { oldFeeBpValue: curFeeBp, newFeeBpValue: feeBpConfig.feeBp, oldEnabledFee: curEnabled, newEnabledFee: feeBpConfig.enabled } });
  }
  return [tx];
}

// src/setConfig.ts
init_abi();
var CONFIG_TYPE_INBOUND_PROOF_LIBRARY_VERSION = 1;
var CONFIG_TYPE_INBOUND_BLOCK_CONFIRMATIONS = 2;
var CONFIG_TYPE_RELAYER = 3;
var CONFIG_TYPE_OUTBOUND_PROOF_TYPE = 4;
var CONFIG_TYPE_OUTBOUND_BLOCK_CONFIRMATIONS = 5;
var CONFIG_TYPE_ORACLE = 6;
var setConfig_default = async (taskArgs, hre) => {
  const configPath = taskArgs.configPath;
  const name = taskArgs.name;
  const address = taskArgs.address;
  const gnosisConfigPath = taskArgs.gnosisConfigPath;
  const sendToGnosis = gnosisConfigPath && configExist(gnosisConfigPath);
  if (!configExist(configPath)) {
    logError(`User application config file is not found`);
    return;
  }
  const config = getConfig(configPath);
  const networks = Object.keys(config);
  const transactionByNetwork = await Promise.all(
    networks.map(async (network) => {
      const transactions = [];
      const chainId = getLayerZeroChainId(network);
      const networkConfig = config[network];
      if (!networkConfig)
        return;
      const endpoint = await getContractAt(hre, network, ENDPOINT_ABI, getEndpointAddress(network));
      const contractName = networkConfig.name ?? name;
      const contractAddress = networkConfig.address ?? address;
      if (!contractName && !contractAddress) {
        logWarning(`Contract information isn't found for ${network}`);
        return;
      }
      const app = contractName ? await getContract(hre, network, contractName) : await getContractAt(hre, network, USER_APPLICATION_ABI, contractAddress);
      const appConfig = await endpoint.uaConfigLookup(app.address);
      const sendLibraryAddress = appConfig.sendVersion === 0 ? await endpoint.defaultSendLibrary() : appConfig.sendLibrary;
      const sendLibrary = await getContractAt(hre, network, MESSAGING_LIBRARY_ABI, sendLibraryAddress);
      let receiveLibrary;
      if (appConfig.sendVersion !== appConfig.receiveVersion) {
        const receiveLibraryAddress = appConfig.receiveVersion === 0 ? await endpoint.defaultReceiveLibraryAddress() : appConfig.receiveLibraryAddress;
        receiveLibrary = await getContractAt(hre, network, MESSAGING_LIBRARY_ABI, receiveLibraryAddress);
      }
      if (networkConfig.sendVersion) {
        transactions.push(...await setSendVersion(chainId, app, appConfig.sendVersion, networkConfig.sendVersion));
      }
      if (networkConfig.receiveVersion) {
        transactions.push(...await setReceiveVersion(chainId, app, appConfig.receiveVersion, networkConfig.receiveVersion));
      }
      const remoteConfigs = networkConfig.remoteConfigs;
      const newSendVersion = networkConfig.sendVersion ?? appConfig.sendVersion;
      const newReceiveVersion = networkConfig.receiveVersion ?? appConfig.receiveVersion;
      if (remoteConfigs) {
        await Promise.all(
          remoteConfigs.map(async (newConfig) => {
            if (newConfig.remoteChain === network)
              return;
            const oldConfig = await getApplicationConfig(newConfig.remoteChain, sendLibrary, receiveLibrary, app.address);
            const remoteChainId = getLayerZeroChainId(newConfig.remoteChain);
            if (newConfig.inboundProofLibraryVersion) {
              transactions.push(...await setConfig(newReceiveVersion, chainId, remoteChainId, app, CONFIG_TYPE_INBOUND_PROOF_LIBRARY_VERSION, "uint16", oldConfig.inboundProofLibraryVersion, newConfig.inboundProofLibraryVersion));
            }
            if (newConfig.inboundBlockConfirmations) {
              transactions.push(...await setConfig(newReceiveVersion, chainId, remoteChainId, app, CONFIG_TYPE_INBOUND_BLOCK_CONFIRMATIONS, "uint64", oldConfig.inboundBlockConfirmations, newConfig.inboundBlockConfirmations));
            }
            if (newConfig.relayer) {
              transactions.push(...await setConfig(newSendVersion, chainId, remoteChainId, app, CONFIG_TYPE_RELAYER, "address", oldConfig.relayer, newConfig.relayer));
            }
            if (newConfig.outboundProofType) {
              transactions.push(...await setConfig(newSendVersion, chainId, remoteChainId, app, CONFIG_TYPE_OUTBOUND_PROOF_TYPE, "uint16", oldConfig.outboundProofType, newConfig.outboundProofType));
            }
            if (newConfig.outboundBlockConfirmations) {
              transactions.push(...await setConfig(newSendVersion, chainId, remoteChainId, app, CONFIG_TYPE_OUTBOUND_BLOCK_CONFIRMATIONS, "uint64", oldConfig.outboundBlockConfirmations, newConfig.outboundBlockConfirmations));
            }
            if (newConfig.oracle) {
              transactions.push(...await setConfig(newSendVersion, chainId, remoteChainId, app, CONFIG_TYPE_ORACLE, "address", oldConfig.oracle, newConfig.oracle));
            }
          })
        );
      }
      return {
        network,
        transactions
      };
    })
  );
  const totalTransactionsNeedingChange = transactionByNetwork.reduce((count, { transactions }) => {
    count += transactions.filter((tx) => tx.needChange).length;
    return count;
  }, 0);
  if (totalTransactionsNeedingChange == 0) {
    console.log("No changes needed");
    return;
  }
  const columns = ["chainId", "remoteChainId", "contractAddress", "functionName", "args", "diff"];
  printTransactions(columns, transactionByNetwork);
  writeToCsv("setConfigTransactions.csv", columns, transactionByNetwork);
  await promptToProceed(`Would you like to proceed with the above instructions ${sendToGnosis ? "in Gnosis?" : "?"}`);
  const errors = [];
  const print = {};
  let previousPrintLine = 0;
  const printResult = () => {
    if (previousPrintLine) {
      process.stdout.moveCursor(0, -previousPrintLine);
    }
    if (Object.keys(print)) {
      previousPrintLine = Object.keys(print).length + 4;
      console.table(Object.keys(print).map((network) => ({ network, ...print[network] })));
    }
  };
  if (sendToGnosis) {
    const gnosisConfig = getConfig(gnosisConfigPath);
    await Promise.all(
      transactionByNetwork.map(async ({ network, transactions }) => {
        const transactionToCommit = transactions.filter((transaction) => transaction.needChange);
        print[network] = print[network] || { requests: "1/1" };
        print[network].current = `executeGnosisTransactions: ${transactionToCommit}`;
        try {
          await executeGnosisTransactions(hre, network, gnosisConfig, transactionToCommit);
          print[network].requests = "1/1";
        } catch (err) {
          errors.push({ network, err });
          print[network].current = err.message;
          print[network].err = true;
        }
      })
    );
    printResult();
    if (errors.length) {
      logError(`
Finished with ${errors.length === 1 ? "an error" : `${errors.length} errors`}`, false);
      errors.forEach((x) => {
        console.log(x.err);
        console.log();
      });
    }
  } else {
    await Promise.all(
      transactionByNetwork.map(async ({ network, transactions }) => {
        const transactionToCommit = transactions.filter((transaction) => transaction.needChange);
        const networkConfig = config[network];
        const contractName = networkConfig.name ?? name;
        const contractAddress = networkConfig.address ?? address;
        const app = contractName ? await getWalletContract(hre, network, contractName) : await getWalletContractAt(hre, network, USER_APPLICATION_ABI, contractAddress);
        let successTx = 0;
        print[network] = print[network] || { requests: `${successTx}/${transactionToCommit.length}` };
        for (let transaction of transactionToCommit) {
          print[network].current = `${transaction.functionName}(${transaction.args})`;
          printResult();
          try {
            const gasLimit = taskArgs.gasLimit;
            const tx = await executeTransaction(hre, network, transaction, gasLimit, app);
            print[network].past = `${transaction.functionName}(${transaction.args}) (${tx.transactionHash})`;
            successTx++;
            print[network].requests = `${successTx}/${transactionToCommit.length}`;
            printResult();
          } catch (err) {
            logError(`Failing to call ${transaction.contractName}.${transaction.functionName} on ${network} with an error ${err}`);
            errors.push({ network, err });
            print[network].current = err;
            print[network].err = true;
            printResult();
            break;
          }
        }
      })
    );
  }
  if (!errors.length) {
    logSuccess("\nFinished successfully");
  }
};
var setSendVersion = async (chainId, app, oldSendVersion, newSendVersion) => {
  const needChange = oldSendVersion !== newSendVersion;
  const contractAddress = app.address;
  const functionName = "setSendVersion";
  const args = [newSendVersion];
  const calldata = app.interface.encodeFunctionData(functionName, args);
  const diff = needChange ? { oldValue: oldSendVersion, newValue: newSendVersion } : void 0;
  return [{ needChange, chainId, contractAddress, functionName, args, calldata, diff }];
};
var setReceiveVersion = async (chainId, app, currentReceiveVersion, newReceiveVersion) => {
  const needChange = currentReceiveVersion !== newReceiveVersion;
  const contractAddress = app.address;
  const functionName = "setReceiveVersion";
  const args = [newReceiveVersion];
  const calldata = app.interface.encodeFunctionData(functionName, args);
  const diff = needChange ? { oldValue: currentReceiveVersion, newValue: newReceiveVersion } : void 0;
  return [{ needChange, chainId, contractAddress, functionName, args, calldata, diff }];
};
var setConfig = async (configVersion, chainId, remoteChainId, app, configType, configValueType, oldValue, newValue) => {
  const newConfig = ethers.utils.defaultAbiCoder.encode([configValueType], [newValue]);
  const contractAddress = app.address;
  const functionName = "setConfig";
  const args = [configVersion, remoteChainId, configType, newConfig];
  const needChange = oldValue !== newValue;
  const calldata = app.interface.encodeFunctionData(functionName, args);
  const diff = needChange ? { oldValue, newValue } : void 0;
  return [{ needChange, chainId, remoteChainId, contractAddress, functionName, args, calldata, diff }];
};
var { ENDPOINT_ABI: ENDPOINT_ABI2, MESSAGING_LIBRARY_ABI: MESSAGING_LIBRARY_ABI2 } = (init_abi(), __toCommonJS(abi_exports));
var getDefaultConfig_default = async (taskArgs, hre) => {
  const networks = taskArgs.networks.split(",");
  const configByNetwork = await Promise.all(
    networks.map(async (network) => {
      const provider = getProvider(hre, network);
      console.log();
      const endpoint = new ethers.ethers.Contract(getEndpointAddress(network), ENDPOINT_ABI2, provider);
      const sendVersion = await endpoint.defaultSendVersion();
      const receiveVersion = await endpoint.defaultReceiveVersion();
      const sendLibraryAddress = await endpoint.defaultSendLibrary();
      const messagingLibrary = new ethers.ethers.Contract(sendLibraryAddress, MESSAGING_LIBRARY_ABI2, provider);
      const config = await messagingLibrary.defaultAppConfig(getLayerZeroChainId(network));
      return {
        network,
        sendVersion,
        receiveVersion,
        inboundProofLibraryVersion: config.inboundProofLibraryVersion,
        inboundBlockConfirmations: config.inboundBlockConfirmations.toNumber(),
        relayer: config.relayer,
        outboundProofType: config.outboundProofType,
        outboundBlockConfirmations: config.outboundBlockConfirmations.toNumber(),
        oracle: config.oracle
      };
    })
  );
  console.table(configByNetwork);
};
init_abi();
var getRemoteConfig = async (remoteNetwork, sendLibrary, receiveLibrary, contractAddress) => {
  const appConfig = await exponentialBackoff.backOff(async () => getApplicationConfig(remoteNetwork, sendLibrary, receiveLibrary, contractAddress));
  const defaultAppConfig = await exponentialBackoff.backOff(async () => sendLibrary.defaultAppConfig(getLayerZeroChainId(remoteNetwork)));
  return {
    remoteChain: remoteNetwork,
    inboundProofLibraryVersion: appConfig.inboundProofLibraryVersion > 0 ? appConfig.inboundProofLibraryVersion : defaultAppConfig.inboundProofLibraryVersion,
    inboundBlockConfirmations: appConfig.inboundBlockConfirmations > 0 ? appConfig.inboundBlockConfirmations : defaultAppConfig.inboundBlockConfirmations.toNumber(),
    relayer: appConfig.relayer != ethers.ethers.constants.AddressZero ? appConfig.relayer : defaultAppConfig.relayer,
    outboundProofType: appConfig.outboundProofType > 0 ? appConfig.outboundProofType : defaultAppConfig.outboundProofType,
    outboundBlockConfirmations: appConfig.outboundBlockConfirmations > 0 ? appConfig.outboundBlockConfirmations : defaultAppConfig.outboundBlockConfirmations.toNumber(),
    oracle: appConfig.oracle != ethers.ethers.constants.AddressZero ? appConfig.oracle : defaultAppConfig.oracle
  };
};
var getRemoteConfigs = async (hre, network, contractAddress, remoteNetworks, sendLibrary, receiveLibrary, checkConnectionFunctionFragment) => {
  const connectedRemoteNetworks = await Promise.all(
    remoteNetworks.filter(async (remoteNetwork) => isConnected(hre, network, contractAddress, remoteNetwork, checkConnectionFunctionFragment))
  );
  return Promise.all(connectedRemoteNetworks.map(async (remoteNetwork) => getRemoteConfig(remoteNetwork, sendLibrary, receiveLibrary, contractAddress)));
};
var isConnected = async (hre, network, contractAddress, remoteNetwork, checkConnectionFunctionFragment) => {
  const abi = [checkConnectionFunctionFragment];
  const remoteChainId = getLayerZeroChainId(remoteNetwork);
  const key = checkConnectionFunctionFragment.split(" ")[1];
  const app = await getContractAt(hre, network, abi, contractAddress);
  const val = await exponentialBackoff.backOff(async () => app[key](remoteChainId));
  return val.length > 0;
};
var getVersions = async (endpoint, contractAddress, provider) => {
  const {
    sendVersion: uaSendVersion,
    receiveVersion: uaReceiveVersion,
    sendLibrary: uaSendLibraryAddress,
    receiveLibraryAddress: uaReceiveLibraryAddress
  } = await endpoint.uaConfigLookup(contractAddress);
  let sendLibraryAddress, sendVersion;
  if (uaSendVersion === 0) {
    sendLibraryAddress = await endpoint.defaultSendLibrary();
    sendVersion = await endpoint.defaultSendVersion();
  } else {
    sendLibraryAddress = uaSendLibraryAddress;
    sendVersion = uaSendVersion;
  }
  const sendLibrary = new ethers.ethers.Contract(sendLibraryAddress, MESSAGING_LIBRARY_ABI, provider);
  let receiveLibraryAddress, receiveVersion;
  if (uaReceiveVersion === 0) {
    receiveLibraryAddress = await endpoint.defaultReceiveLibraryAddress();
    receiveVersion = await endpoint.defaultReceiveVersion();
  } else {
    receiveLibraryAddress = uaReceiveLibraryAddress;
    receiveVersion = uaReceiveVersion;
  }
  const receiveLibrary = new ethers.ethers.Contract(receiveLibraryAddress, MESSAGING_LIBRARY_ABI, provider);
  return {
    sendVersion,
    receiveVersion,
    sendLibrary,
    receiveLibrary
  };
};
var generateAppConfig = async (hre, configs, checkConnectionFunctionFragment, name) => {
  const networks = Object.keys(configs);
  return networks.reduce(async (acc, network) => {
    const provider = getProvider(hre, network);
    const endpointAddress = getEndpointAddress(network);
    const endpoint = new ethers.ethers.Contract(endpointAddress, ENDPOINT_ABI, provider);
    const address = configs[network].address;
    const { sendVersion, sendLibrary, receiveVersion, receiveLibrary } = await getVersions(endpoint, address, provider);
    const remoteConfigs = await getRemoteConfigs(hre, network, address, networks, sendLibrary, receiveLibrary, checkConnectionFunctionFragment);
    return {
      ...await acc,
      [network]: {
        ...name && { name },
        sendVersion,
        receiveVersion,
        address,
        remoteConfigs
      }
    };
  }, Promise.resolve({}));
};
var getContractConfigs = (inputNetworks, name) => {
  return inputNetworks.split(",").reduce((acc, inputNetwork) => {
    const [key, value] = inputNetwork.split(":");
    return {
      ...acc,
      [key]: {
        address: value ? value : getDeploymentAddress(key, name)
      }
    };
  }, {});
};
var checkOutputFileName = (fileName) => {
  if (!fileName) {
    throw new Error("Output file name is required.");
  }
  if (!fileName.endsWith(".json")) {
    throw new Error("Output file name must end with .json.");
  }
  if (fileName.startsWith("/")) {
    throw new Error("Output file name must be relative.");
  }
};
var generateAppConfigAction = async (taskArgs, hre) => {
  const { networks: inputNetworks, name, outputFileName, checkConnectionFunctionFragment } = taskArgs;
  const configs = getContractConfigs(inputNetworks, name);
  checkOutputFileName(outputFileName);
  const defaultConfigMesh = await generateAppConfig(hre, configs, checkConnectionFunctionFragment, name);
  await promises.writeFile(outputFileName, JSON.stringify(defaultConfigMesh, null, 2));
};

// src/getConfig.ts
init_abi();
var getConfig_default = async (taskArgs, hre) => {
  const network = hre.network.name;
  const remoteNetworks = taskArgs.remoteNetworks.split(",");
  const contractName = taskArgs.name;
  let contractAddress = taskArgs.address;
  if (!contractName && !contractAddress) {
    logError("Provide contract name or address");
    return;
  }
  if (contractName && !contractAddress) {
    contractAddress = getDeploymentAddresses(network, false)[contractName];
    if (!contractAddress) {
      logError(`Deployment information isn't found for ${contractName}`);
      return;
    }
  }
  const endpoint = await getContractAt(hre, network, ENDPOINT_ABI, getEndpointAddress(network));
  const appConfig = await endpoint.uaConfigLookup(contractAddress);
  const sendVersion = appConfig.sendVersion;
  const receiveVersion = appConfig.receiveVersion;
  const sendLibraryAddress = sendVersion === 0 ? await endpoint.defaultSendLibrary() : appConfig.sendLibrary;
  const sendLibrary = await getContractAt(hre, network, MESSAGING_LIBRARY_ABI, sendLibraryAddress);
  let receiveLibrary;
  if (sendVersion !== receiveVersion) {
    const receiveLibraryAddress = receiveVersion === 0 ? await endpoint.defaultReceiveLibraryAddress() : appConfig.receiveLibraryAddress;
    receiveLibrary = await getContractAt(hre, network, MESSAGING_LIBRARY_ABI, receiveLibraryAddress);
  }
  const remoteConfig = await Promise.all(
    remoteNetworks.map(async (remoteNetwork) => {
      if (network === remoteNetwork)
        return;
      return await getApplicationConfig(remoteNetwork, sendLibrary, receiveLibrary, contractAddress);
    })
  );
  console.log("Network            ", network);
  console.log("Application address", contractAddress);
  console.log("Send version       ", sendVersion);
  console.log("Receive version    ", receiveVersion);
  console.table(remoteConfig);
};

// src/checkWireAllConfig.ts
init_abi();
async function checkWireAllConfig_default(taskArgs, hre) {
  const localNetworks = taskArgs.chains.split(",");
  const remoteNetworks = localNetworks;
  const contractAddresses = taskArgs?.addresses?.split(",");
  let checkWireAllConfigObj = {};
  await Promise.all(
    localNetworks.map(async (localNetwork, localIndex) => {
      checkWireAllConfigObj[localNetwork] = {
        useCustomAdapterParams: {},
        withdrawalFeeBps: {},
        minDstGasLookup: {},
        trustedRemoteLookup: {}
      };
      checkWireAllConfigObj[localNetwork].useCustomAdapterParams["useCustomAdapterParams"] = "";
      checkWireAllConfigObj[localNetwork].withdrawalFeeBps["withdrawalFeeBps"] = "";
      checkWireAllConfigObj[localNetwork].minDstGasLookup[localNetwork] = "";
      checkWireAllConfigObj[localNetwork].trustedRemoteLookup[localNetwork] = "";
      let localContractNameOrAddress;
      if (taskArgs?.proxyChain && taskArgs?.proxyContract && localNetwork == taskArgs?.proxyChain) {
        localContractNameOrAddress = taskArgs?.proxyContract;
      } else if (taskArgs?.contract !== void 0) {
        localContractNameOrAddress = taskArgs.contract;
      } else if (contractAddresses !== void 0) {
        localContractNameOrAddress = contractAddresses[localIndex];
      }
      if (localContractNameOrAddress === void 0 && contractAddresses === void 0) {
        logError(`Invalid wire up config for localContractNameOrAddress.`);
        return;
      }
      if (taskArgs.u)
        checkWireAllConfigObj[localNetwork].useCustomAdapterParams["useCustomAdapterParams"] = await getUseCustomAdapterParams(hre, localNetwork, localContractNameOrAddress);
      if (taskArgs.wfb)
        checkWireAllConfigObj[localNetwork].withdrawalFeeBps["withdrawalFeeBps"] = await getWithdrawalFeeBps(hre, localNetwork, localContractNameOrAddress);
      await Promise.all(
        remoteNetworks.map(async (remoteNetwork, remoteIndex) => {
          let remoteContractNameOrAddress;
          if (taskArgs?.proxyChain && taskArgs?.proxyContract && remoteNetwork == taskArgs?.proxyChain) {
            remoteContractNameOrAddress = taskArgs?.proxyContract;
          } else if (taskArgs?.contract !== void 0) {
            remoteContractNameOrAddress = taskArgs.contract;
          } else if (contractAddresses !== void 0) {
            remoteContractNameOrAddress = contractAddresses[remoteIndex];
          }
          if (remoteContractNameOrAddress === void 0 && contractAddresses === void 0) {
            logError(`Invalid wire up config for remoteContractNameOrAddress.`);
            return;
          }
          if (taskArgs.t)
            checkWireAllConfigObj[localNetwork].trustedRemoteLookup[remoteNetwork] = await getTrustedRemote(hre, localNetwork, localContractNameOrAddress, remoteNetwork, remoteContractNameOrAddress);
          if (taskArgs.m)
            checkWireAllConfigObj[localNetwork].minDstGasLookup[remoteNetwork] = await getMinDstGas(hre, localNetwork, localContractNameOrAddress, remoteNetwork);
        })
      );
    })
  );
  if (taskArgs.u) {
    console.log("Use Custom Adapter Params Table");
    let useCustomAdapterParamsTable = Object.keys(checkWireAllConfigObj).map((network) => ({ [network]: checkWireAllConfigObj[network].useCustomAdapterParams }));
    console.table(useCustomAdapterParamsTable.reduce((r, c) => Object.assign(r, c), {}));
  }
  if (taskArgs.wfb) {
    console.log("Withdrawal Fee Bps Lookup Table");
    let minDstGasLookupTable = Object.keys(checkWireAllConfigObj).map((network) => ({ [network]: checkWireAllConfigObj[network].withdrawalFeeBps }));
    console.table(minDstGasLookupTable.reduce((r, c) => Object.assign(r, c), {}));
  }
  if (taskArgs.t) {
    console.log("Trusted Remote Lookup Table");
    let trustedRemoteLookupTable = Object.keys(checkWireAllConfigObj).map((network) => ({ [network]: checkWireAllConfigObj[network].trustedRemoteLookup }));
    console.table(trustedRemoteLookupTable.reduce((r, c) => Object.assign(r, c), {}));
  }
  if (taskArgs.m) {
    console.log("Min Dst Gas Lookup Table");
    let minDstGasLookupTable = Object.keys(checkWireAllConfigObj).map((network) => ({ [network]: checkWireAllConfigObj[network].minDstGasLookup }));
    console.table(minDstGasLookupTable.reduce((r, c) => Object.assign(r, c), {}));
  }
}
async function getUseCustomAdapterParams(hre, localNetwork, localContractNameOrAddress) {
  let localContract;
  if (hre.ethers.utils.isAddress(localContractNameOrAddress)) {
    localContract = await getContractAt(hre, localNetwork, LZ_APP_ABI, localContractNameOrAddress);
  } else {
    localContract = await getContract(hre, localNetwork, localContractNameOrAddress);
  }
  return await localContract.useCustomAdapterParams();
}
async function getWithdrawalFeeBps(hre, localNetwork, localContractNameOrAddress) {
  let localContract;
  if (hre.ethers.utils.isAddress(localContractNameOrAddress)) {
    localContract = await getContractAt(hre, localNetwork, LZ_APP_ABI, localContractNameOrAddress);
  } else {
    localContract = await getContract(hre, localNetwork, localContractNameOrAddress);
  }
  let withdrawalFeeBps;
  try {
    withdrawalFeeBps = await localContract.withdrawalFeeBps();
  } catch (e) {
    withdrawalFeeBps = "N/A";
  }
  return withdrawalFeeBps;
}
async function getMinDstGas(hre, localNetwork, localContractNameOrAddress, remoteNetwork) {
  let localContract;
  if (hre.ethers.utils.isAddress(localContractNameOrAddress)) {
    localContract = await getContractAt(hre, localNetwork, LZ_APP_ABI, localContractNameOrAddress);
  } else {
    localContract = await getContract(hre, localNetwork, localContractNameOrAddress);
  }
  let packetTypes;
  if (localNetwork === remoteNetwork)
    return "";
  const remoteChainId = getLayerZeroChainId(remoteNetwork);
  let minGasPk_0 = await localContract.minDstGasLookup(remoteChainId, 0);
  let minGasPk_1 = await localContract.minDstGasLookup(remoteChainId, 1);
  packetTypes = {
    "PT_0": minGasPk_0.toString(),
    "PT_1": minGasPk_1.toString()
  };
  return packetTypes;
}
async function getTrustedRemote(hre, localNetwork, localContractNameOrAddress, remoteNetwork, remoteContractNameOrAddress) {
  let localContract;
  if (hre.ethers.utils.isAddress(localContractNameOrAddress)) {
    localContract = await getContractAt(hre, localNetwork, LZ_APP_ABI, localContractNameOrAddress);
  } else {
    localContract = await getContract(hre, localNetwork, localContractNameOrAddress);
  }
  let remoteContract;
  if (hre.ethers.utils.isAddress(remoteContractNameOrAddress)) {
    remoteContract = await getContractAt(hre, remoteNetwork, LZ_APP_ABI, remoteContractNameOrAddress);
  } else {
    remoteContract = await getContract(hre, remoteNetwork, remoteContractNameOrAddress);
  }
  const remoteContractAddress = await remoteContract.address;
  const desiredTrustedRemote = hre.ethers.utils.solidityPack(["bytes"], [remoteContractAddress + localContract.address.substring(2)]);
  const remoteChainId = getLayerZeroChainId(remoteNetwork);
  const currentTrustedRemote = await localContract.trustedRemoteLookup(remoteChainId);
  return currentTrustedRemote != desiredTrustedRemote ? localNetwork === remoteNetwork ? "" : "\u{1F7E5}" : "\u{1F7E9}";
}

// src/index.ts
config.task("setConfig", "sets Send and Receive Messaging Library versions and a custom application config for contracts implementing ILayerZeroUserApplicationConfig interface", setConfig_default).addParam("configPath", "the application config file path").addOptionalParam("name", "name of the deployed contracts. Should be specified if the same contract deployed on different chains and the deployment information is located in the deployments folder").addOptionalParam("address", "address of the deployed contracts. Should be specified if the contract address is the same on all chains").addOptionalParam("gnosisConfigPath", "the path to a file with Gnosis config. If specified, the transactions will be sent to Gnosis").addOptionalParam("gasLimit", "override execution gasLimit");
config.task("getDefaultConfig", "outputs the default Send and Receive Messaging Library versions and the default application config", getDefaultConfig_default).addParam("networks", "comma separated list of networks");
config.task("generateAppConfig", "generates the config mesh for a User Application", generateAppConfigAction).addParam("networks", "comma separated list of networks").addOptionalParam("name", "name of the deployed contract. Should be specified only if the deployment information is located in the deployments folder").addOptionalParam("outputFileName", "the path to the output file", "./constants/defaultConfig.json", config.types.string).addOptionalParam("checkConnectionFunctionFragment", "the checkConnection function fragment", LZ_APP_TRUSTED_REMOTE_LOOKUP_FUNCTION_FRAGMENT, config.types.string);
config.task("getConfig", "outputs the application's Send and Receive Messaging Library versions and the config for remote networks", getConfig_default).addParam("remoteNetworks", "comma separated list of remote networks").addOptionalParam("name", "name of the deployed contract. Should be specified only if the deployment information is located in the deployments folder").addOptionalParam("address", "the contract address");
config.task("checkWireAllConfig", "", checkWireAllConfig_default).addParam("e", "the environment ie: mainnet, testnet or sandbox").addFlag("u", "show use custom adapter params").addFlag("t", "show trusted remote lookup").addFlag("m", "show min destination gas lookup").addParam("chains", "comma separated list of networks").addOptionalParam("contract", "name of contract").addOptionalParam("addresses", "addresses of contracts in same order as chains").addOptionalParam("proxyContract", "name of proxy contract").addOptionalParam("proxyChain", "name of proxy chain");
config.task("wireAll", "", wireAll_default).addParam("e", "the environment ie: mainnet, testnet or sandbox").addOptionalParam("noPrompt", "no prompt", false, config.types.boolean).addOptionalParam("configPath", "Optional config path. Default: ./constants/wireUpConfig.json", "./constants/wireUpConfig.json", config.types.string).addOptionalParam("n", "send to gnosis", false, config.types.boolean).addOptionalParam("gasLimit", "override execution gasLimit").addOptionalParam("gnosisConfigPath", "Optional config path. Default: ./constants/gnosisConfig.json", "./constants/gnosisConfig.json", config.types.string);
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.js.map